<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>fujiwarannosato 3Dビューア 複数ボックス</title>
  <style>
    body{margin:0;overflow:hidden;background:#444}
    canvas{display:block}
    #tooltip{position:absolute;display:none;z-index:10;background:rgba(255,255,255,.95);border:1px solid #999;border-radius:6px;padding:6px;font:14px/1 sans-serif}
    #tooltip img{width:160px;height:auto;display:block;margin-bottom:4px}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
<div id="tooltip"></div>
<script>
/***** 0. 基本セットアップ *****/
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xcccccc);
scene.add(new THREE.AxesHelper(100));
const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,40,70);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);
const controls = new THREE.OrbitControls(camera,renderer.domElement);
controls.target.set(0,5,0); controls.update();
scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const sun = new THREE.DirectionalLight(0xffffff,1.2);
sun.position.set(-2000,500,0);
scene.add(sun);

/***** 1. モデル読み込み *****/
new THREE.GLTFLoader().load('test.glb',g=>{
  const m=g.scene;m.scale.set(3.0,3.0,3.0);
  const deg=d=>d*Math.PI/180; m.rotation.set(deg(270),deg(0),deg(0));
  m.traverse(obj=>{
    if(obj.isMesh && obj.material && obj.material.color){
      obj.material.color.multiplyScalar(1.1);
    }
  });
  scene.add(m);
});

/***** 2. スプライト定義（省略: いままで通り） *****/
const spriteInfo = [
  { img:'1.png', pos:[ 7, 5, 25], label:'① 校庭の動画を見る', thumb:'thumb1.jpg', url:'https://youtu.be/i3zNW7IayQI' },
  { img:'2.png', pos:[ 11, 6, -23], label:'② 校舎の紹介', thumb:'thumb2.jpg', url:'https://youtu.be/J4syLpke3Vw' },
  { img:'3.png', pos:[40, 3, 45], label:'③ 川と桜の動画', thumb:'thumb3.jpg', url:'https://youtu.be/evLFb1z0xEI' },
  { img:'4.png', pos:[-30, 8,  -40], label:'④ プールエリア', thumb:'thumb4.jpg', url:'https://youtu.be/wUhEjw1rA2o' },
  { img:'5.png', pos:[ 33, 1,  -44], label:'⑤ 付近の魚道', thumb:'thumb5.jpg', url:'https://youtu.be/HUzOqBaEruw' }
];
const sprites=[], tex=new THREE.TextureLoader();
spriteInfo.forEach(d=>{
  const sp=new THREE.Sprite(new THREE.SpriteMaterial({map:tex.load(d.img),transparent:true}));
  sp.scale.set(3,3,1);
  sp.position.set(...d.pos);
  sp.userData=d;
  scene.add(sp);
  sprites.push(sp);
});

/***** 3. 自動回転制御（省略: いままで通り） *****/
const REV_PER_MIN=0.5;
const ANG_SPEED = REV_PER_MIN*2*Math.PI/60;
const AUTO_DELAY=10000;
let   autoRot=true; let lastUser=performance.now();
let   currentAngle=0; let lastFrame=performance.now();
const radius=camera.position.length(); const baseY=camera.position.y;
function stopAuto(){autoRot=false;lastUser=performance.now();}
addEventListener('pointerdown',stopAuto); addEventListener('wheel',stopAuto);

/***** 4. 複数ボックス定義＋生成 *****/
const boxDefs = [
  // 1つめ（元の例）
  {
    color: 0x00ffff, link: "https://youtu.be/dQw4w9WgXcQ",
    pos: [10,2,-5], rot: [0, Math.PI/4, 0], // Y軸45度
    size: [18,3,25]
  },
  // 2つめ（例：ちょっと右に、赤でZ軸ひねり）
  {
    color: 0xff3333, link: "https://youtu.be/J4syLpke3Vw",
    pos: [35,4,-15], rot: [0, 0, Math.PI/6], // Z軸30度
    size: [14,3,18]
  },
  // 3つめ（例：左後ろ、緑でX軸ひねり）
  {
    color: 0x33ff99, link: "https://youtu.be/i3zNW7IayQI",
    pos: [-20,8,30], rot: [Math.PI/8, 0, 0], // X軸22.5度
    size: [10,2,10]
  }
];
// アニメ用管理もまとめて配列化
const boxMeshes = [], boxMats = [], boxOrigins = [], boxTargets = [], boxPhases = [];

boxDefs.forEach((def,i)=>{
  const geom = new THREE.BoxGeometry(...def.size);
  const mat = new THREE.MeshBasicMaterial({color:def.color,transparent:true,opacity:0.35});
  const mesh = new THREE.Mesh(geom, mat);
  mesh.position.set(...def.pos);
  mesh.rotation.set(...def.rot);
  mesh.visible = false;
  mesh.userData = { url: def.link };
  scene.add(mesh);

  // アニメ状態初期化
  boxMeshes.push(mesh);
  boxMats.push(mat);
  boxOrigins.push(def.pos[1]);
  boxTargets.push(def.pos[1]+30); // ←30上昇ループ
  boxPhases.push(0);
});

/***** 5. ホバー処理 & クリック（複数ボックス）*****/
const ray = new THREE.Raycaster(); const mouse = new THREE.Vector2();
const tip=document.getElementById('tooltip');
let cur=null, mousePixX=0, mousePixY=0;
let boxHoverIndex = -1; // 何番目のボックスがヒットしてるか

addEventListener('mousemove',e=>{
  mousePixX=e.clientX; mousePixY=e.clientY;
  mouse.x=(e.clientX/innerWidth)*2-1;
  mouse.y=-(e.clientY/innerHeight)*2+1;
  ray.setFromCamera(mouse, camera);

  // スプライト判定
  const hit = ray.intersectObjects(sprites)[0]?.object||null;
  if(hit!==cur){ cur=hit; tip.style.display=cur?'block':'none'; }
  if(cur){
    const d=cur.userData;
    tip.innerHTML=`<img src="${d.thumb}"><strong>${d.label}</strong>`;
    tip.style.left=mousePixX+12+'px'; tip.style.top=mousePixY+12+'px';
  }

  // 複数ボックス判定
  boxHoverIndex = -1;
  for(let i=0; i<boxMeshes.length; ++i){
    const hits = ray.intersectObject(boxMeshes[i]);
    if(hits.length>0){ boxHoverIndex = i; break; }
  }

  // カーソル切り替え
  document.body.style.cursor = (boxHoverIndex>=0 || cur) ? 'pointer' : '';
});

addEventListener('click',()=>{
  // 複数ボックスクリック
  if(boxHoverIndex >= 0 && boxMeshes[boxHoverIndex].userData.url){
    window.open(boxMeshes[boxHoverIndex].userData.url, "_blank");
  }
  // スプライトクリック
  if(cur && cur.userData.url){
    window.open(cur.userData.url, "_blank");
  }
});

/***** 6. ループ（複数ボックス繰り返しアニメ付き）*****/
function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = Math.min((now-lastFrame)/1000, 0.1); lastFrame=now;

  // 自動回転
  if(!autoRot&&now-lastUser>AUTO_DELAY) autoRot=true;
  if(autoRot){
    currentAngle+=ANG_SPEED*dt;
    camera.position.x=radius*Math.sin(currentAngle);
    camera.position.z=radius*Math.cos(currentAngle);
    camera.position.y=baseY;
    camera.lookAt(0,5,0);
  }
  controls.update();

  // 複数ボックスアニメ
  const animSpeed = 0.5;
  for(let i=0;i<boxMeshes.length;++i){
    if(boxHoverIndex===i){
      boxMeshes[i].visible = true;
      boxPhases[i] += dt * animSpeed;
      if(boxPhases[i]>1) boxPhases[i] -= 1;
      const y = boxOrigins[i] + (boxTargets[i]-boxOrigins[i]) * boxPhases[i];
      const alpha = 0.35 * (1 - boxPhases[i]);
      boxMeshes[i].position.y = y;
      boxMats[i].opacity = alpha;
    }else{
      boxMeshes[i].visible = false;
      boxPhases[i] = 0;
      boxMeshes[i].position.y = boxOrigins[i];
      boxMats[i].opacity = 0.35;
    }
  }

  renderer.render(scene,camera);
}
animate();

addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>