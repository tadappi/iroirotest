<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Three.js GLB Viewer – adjustable axes, lights, rotation</title>
  <style>
    html, body { height: 100%; margin: 0; }
    #app { position: fixed; inset: 0; background: #0b0e13; }
    .hint { position: fixed; left: 12px; bottom: 12px; color: #cbd5e1; font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; opacity: .85; }
    .hint kbd{background:#111827;color:#e5e7eb;border:1px solid #374151;border-bottom-width:2px;border-radius:6px;padding:2px 6px;font:11px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .error { position: fixed; top: 12px; left: 50%; transform: translateX(-50%); background: #fee2e2; color:#991b1b; border:1px solid #fecaca; padding: 10px 14px; border-radius: 8px; font: 13px system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; display:none; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="error" id="error"></div>
  <div class="hint">マウス: <kbd>左</kbd>回転 <kbd>中</kbd>パン <kbd>ホイール</kbd>ズーム ／ GUIで軸・照明・角度を調整</div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

    // ====== Basic setup ======
    const container = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e13);

    const camera = new THREE.PerspectiveCamera(55, container.clientWidth / container.clientHeight, 0.01, 1000);
    camera.position.set(2.5, 1.8, 3.2);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.target.set(0, 0.6, 0);

    // ====== Lights ======
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(3, 5, 2);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    scene.add(dirLight);

    // Optional ground to catch shadows (off by default)
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100),
      new THREE.MeshStandardMaterial({ color: 0x111519, roughness: 1 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    ground.visible = false; // toggleable via GUI
    scene.add(ground);

    // ====== Model root & helpers ======
    const modelGroup = new THREE.Group();
    scene.add(modelGroup);

    // Axes helper attached to model (local axes)
    let axesHelper = new THREE.AxesHelper(1.5);
    modelGroup.add(axesHelper);

    // Optional world grid
    const grid = new THREE.GridHelper(50, 50, 0x334155, 0x1f2937);
    grid.visible = false; // toggleable via GUI
    scene.add(grid);

    // ====== Load model ======
    const params = new URLSearchParams(location.search);
    const modelPath = params.get('model') || 'test.glb'; // place index.html next to test.glb

    const loader = new GLTFLoader();
    loader.load(
      modelPath,
      (gltf) => {
        const obj = gltf.scene || gltf.scenes[0];
        obj.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        modelGroup.add(obj);
        centerAndFrame(obj);
      },
      (xhr) => {
        // progress (optional)
        // console.log(`Loading: ${(xhr.loaded / xhr.total * 100).toFixed(1)}%`);
      },
      (err) => showError(`モデル読み込みに失敗： ${modelPath}<br/>${err.message || err}`)
    );

    function showError(html) {
      const el = document.getElementById('error');
      el.innerHTML = html;
      el.style.display = 'block';
    }

    // Center model and frame camera nicely
    function centerAndFrame(object3D) {
      const box = new THREE.Box3().setFromObject(object3D);
      if (!box.isEmpty()) {
        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size);
        box.getCenter(center);

        // Move model so its center sits at world origin (on ground if it has thickness)
        object3D.position.sub(center);
        // Lift so bottom touches ground
        const minY = box.min.y - center.y;
        object3D.position.y -= minY;

        // Frame camera to fit model
        frameObject(size.length(), new THREE.Vector3(0, size.y * 0.5, 0));
      }
    }

    function frameObject(boxDiagonal, focus) {
      const halfFov = THREE.MathUtils.degToRad(camera.fov * 0.5);
      const distance = (boxDiagonal * 0.6) / Math.tan(halfFov); // 0.6 conservatively fits
      const dir = new THREE.Vector3(1, 0.6, 1).normalize();
      camera.position.copy(focus).addScaledVector(dir, distance);
      camera.near = Math.max(0.01, distance / 1000);
      camera.far = distance * 10;
      camera.updateProjectionMatrix();
      controls.target.copy(focus);
      controls.update();
    }

    // ====== GUI ======
    const gui = new GUI({ title: 'Controls' });

    const axesFolder = gui.addFolder('Axes / Grid');
    const axesOpts = { size: 1.5, showAxes: true, showGrid: false };
    axesFolder.add(axesOpts, 'showAxes').name('Show axes').onChange(v => { axesHelper.visible = v; });
    axesFolder.add(axesOpts, 'showGrid').name('Show grid').onChange(v => { grid.visible = v; });
    axesFolder.add(axesOpts, 'size', 0.1, 10, 0.1).name('Axes size').onChange(v => {
      modelGroup.remove(axesHelper);
      axesHelper = new THREE.AxesHelper(v);
      modelGroup.add(axesHelper);
      axesHelper.visible = axesOpts.showAxes;
    });

    const lightFolder = gui.addFolder('Lighting');
    const lightOpts = {
      ambientIntensity: 0.6,
      ambientColor: '#ffffff',
      dirIntensity: 1.0,
      dirColor: '#ffffff',
      dirX: 3, dirY: 5, dirZ: 2,
      groundShadow: false,
    };
    lightFolder.add(lightOpts, 'ambientIntensity', 0, 5, 0.01).name('Ambient int.').onChange(v => ambientLight.intensity = v);
    lightFolder.addColor(lightOpts, 'ambientColor').name('Ambient color').onChange(v => ambientLight.color.set(v));
    lightFolder.add(lightOpts, 'dirIntensity', 0, 10, 0.01).name('Directional int.').onChange(v => dirLight.intensity = v);
    lightFolder.addColor(lightOpts, 'dirColor').name('Directional color').onChange(v => dirLight.color.set(v));
    lightFolder.add(lightOpts, 'dirX', -20, 20, 0.1).name('Dir X').onChange(v => dirLight.position.x = v);
    lightFolder.add(lightOpts, 'dirY', -20, 20, 0.1).name('Dir Y').onChange(v => dirLight.position.y = v);
    lightFolder.add(lightOpts, 'dirZ', -20, 20, 0.1).name('Dir Z').onChange(v => dirLight.position.z = v);
    lightFolder.add(ground, 'visible').name('Ground shadow');

    const rotFolder = gui.addFolder('Model Rotation');
    const rotOpts = { rotX: 0, rotY: 0, rotZ: 0, reset: () => { rotOpts.rotX = rotOpts.rotY = rotOpts.rotZ = 0; applyRotation(); gui.updateDisplay(); }, frame: () => frameObject(2, new THREE.Vector3(0, 0.6, 0)) };
    rotFolder.add(rotOpts, 'rotX', -Math.PI, Math.PI, 0.001).name('Rotate X').onChange(applyRotation);
    rotFolder.add(rotOpts, 'rotY', -Math.PI, Math.PI, 0.001).name('Rotate Y').onChange(applyRotation);
    rotFolder.add(rotOpts, 'rotZ', -Math.PI, Math.PI, 0.001).name('Rotate Z').onChange(applyRotation);
    rotFolder.add(rotOpts, 'reset').name('Reset rotation');

    function applyRotation() {
      modelGroup.rotation.set(rotOpts.rotX, rotOpts.rotY, rotOpts.rotZ);
    }

    // Extras
    const viewFolder = gui.addFolder('View');
    viewFolder.add({ frame: () => frameObject(2, new THREE.Vector3(0, 0.6, 0)) }, 'frame').name('Re-frame model');
    viewFolder.add({ resetCam: () => { camera.position.set(2.5, 1.8, 3.2); controls.target.set(0, 0.6, 0); controls.update(); } }, 'resetCam').name('Reset camera');

    // ====== Render loop ======
    function render() {
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
    render();

    // ====== Resize ======
    window.addEventListener('resize', () => {
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });

    // ====== Notes ======
    // ・このファイル(index.html)と test.glb を同じフォルダに置いてください。
    // ・GitHub Pages に公開する場合はリポジトリの root に置き、Pages を main / root で有効化。
    // ・別ファイルを試したい時は URL パラメータ ?model=your.glb でも指定できます。
  </script>
</body>
</html>
